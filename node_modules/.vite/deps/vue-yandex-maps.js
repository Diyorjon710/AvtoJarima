import {
  h
} from "./chunk-W73FIMSG.js";
import "./chunk-RSJERJUL.js";

// node_modules/vue-yandex-maps/dist/vue-yandex-maps.esm.js
function t(e2, t2) {
  var n2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    t2 && (o2 = o2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    })), n2.push.apply(n2, o2);
  }
  return n2;
}
function n(e2) {
  for (var n2 = 1; n2 < arguments.length; n2++) {
    var o2 = null != arguments[n2] ? arguments[n2] : {};
    n2 % 2 ? t(Object(o2), true).forEach(function(t2) {
      a(e2, t2, o2[t2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(o2)) : t(Object(o2)).forEach(function(t2) {
      Object.defineProperty(e2, t2, Object.getOwnPropertyDescriptor(o2, t2));
    });
  }
  return e2;
}
function o(e2) {
  return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
    return typeof e3;
  } : function(e3) {
    return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
  })(e2);
}
function r(e2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var o2 = t2[n2];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, o2.key, o2);
  }
}
function a(e2, t2, n2) {
  return t2 in e2 ? Object.defineProperty(e2, t2, { value: n2, enumerable: true, configurable: true, writable: true }) : e2[t2] = n2, e2;
}
function i(e2) {
  return function(e3) {
    if (Array.isArray(e3))
      return s(e3);
  }(e2) || function(e3) {
    if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"])
      return Array.from(e3);
  }(e2) || function(e3, t2) {
    if (!e3)
      return;
    if ("string" == typeof e3)
      return s(e3, t2);
    var n2 = Object.prototype.toString.call(e3).slice(8, -1);
    "Object" === n2 && e3.constructor && (n2 = e3.constructor.name);
    if ("Map" === n2 || "Set" === n2)
      return Array.from(e3);
    if ("Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return s(e3, t2);
  }(e2) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function s(e2, t2) {
  (null == t2 || t2 > e2.length) && (t2 = e2.length);
  for (var n2 = 0, o2 = new Array(t2); n2 < t2; n2++)
    o2[n2] = e2[n2];
  return o2;
}
function c(e2, t2) {
  var n2 = t2.options, o2 = t2.callbacks, r2 = t2.map, a2 = t2.useObjectManager, s2 = t2.objectManagerClusterize, c2 = t2.useHtmlInLayout ? '\n    <div v-html="properties.balloonContentHeader"></div>\n    <div v-html="properties.balloonContentBody"></div>\n    <div v-html="properties.balloonContentFooter"></div>\n  ' : "\n    <div>{{ properties.balloonContentHeader }}</div>\n    <div>{{ properties.balloonContentBody }}</div>\n    <div>{{ properties.balloonContentFooter }}</div>\n  ", l2 = {}, u2 = [];
  if (e2.forEach(function(e3) {
    e3.clusterName ? l2[e3.clusterName] = l2[e3.clusterName] ? [].concat(i(l2[e3.clusterName]), [e3]) : [e3] : u2.push(e3);
  }), Object.keys(l2).forEach(function(e3) {
    var t3 = n2[e3] || {}, i2 = o2[e3] || {}, u3 = t3.layout || c2;
    t3.clusterBalloonItemContentLayout = ymaps.templateLayoutFactory.createClass(u3);
    var p3 = t3.clusterBalloonLayout || t3.clusterLayout;
    delete t3.clusterBalloonLayout;
    var m2 = p3 ? ymaps.templateLayoutFactory.createClass(p3) : t3.clusterBalloonContentLayout || "cluster#balloonTwoColumns";
    t3.clusterBalloonContentLayout = m2;
    var d2 = t3.clusterIconContentLayout;
    if (t3.clusterIconContentLayout = d2 && ymaps.templateLayoutFactory.createClass(d2), a2) {
      var f2 = new ymaps.ObjectManager(Object.assign({ clusterize: s2 }, t3));
      Object.keys(i2).forEach(function(e4) {
        f2.clusters.events.add(e4, i2[e4]);
      }), f2.add(l2[e3]), r2.geoObjects.add(f2);
    } else {
      var h3 = new ymaps.Clusterer(t3);
      Object.keys(i2).forEach(function(e4) {
        h3.events.add(e4, i2[e4]);
      }), t3.createCluster && (h3.createCluster = t3.createCluster), h3.add(l2[e3]), r2.geoObjects.add(h3);
    }
  }), u2.length) {
    var p2 = a2 ? new ymaps.ObjectManager({ clusterize: false }) : new ymaps.GeoObjectCollection();
    u2.forEach(function(e3) {
      return p2.add(e3);
    }), r2.geoObjects.add(p2);
  }
}
function l(e2) {
  return e2.charAt(0).toUpperCase() + e2.slice(1);
}
function u(e2) {
  return (e2.icon.color || "blue") + (e2.icon.glyph ? l(e2.icon.glyph) : e2.icon.content ? "Stretchy" : "");
}
function p(e2) {
  return e2.map(function(e3) {
    return Array.isArray(e3) ? p(e3) : +e3;
  });
}
function m(e2, t2) {
  var n2 = [];
  return function e3(t3, r2) {
    if (t3 === r2)
      return true;
    if (t3 instanceof Date && r2 instanceof Date)
      return +t3 == +r2;
    if ("object" !== o(t3) || "object" !== o(r2))
      return false;
    if (function(e4, t4) {
      for (var o2 = n2.length; o2--; )
        if (!(n2[o2][0] !== e4 && n2[o2][0] !== t4 || n2[o2][1] !== t4 && n2[o2][1] !== e4))
          return true;
      return false;
    }(t3, r2))
      return true;
    n2.push([t3, r2]);
    var a2 = Object.keys(t3), i2 = a2.length;
    if (Object.keys(r2).length !== i2)
      return false;
    for (; i2--; )
      if (!e3(t3[a2[i2]], r2[a2[i2]]))
        return false;
    return true;
  }(e2, t2);
}
var d = new (function() {
  function e2() {
    !function(e3, t3) {
      if (!(e3 instanceof t3))
        throw new TypeError("Cannot call a class as a function");
    }(this, e2), this.events = {}, this.ymapReady = false, this.scriptIsNotAttached = true;
  }
  var t2, n2, o2;
  return t2 = e2, (n2 = [{ key: "$on", value: function(e3, t3) {
    var n3 = this;
    return this.events[e3] || (this.events[e3] = []), this.events[e3].push(t3), function() {
      n3.events[e3] = n3.events[e3].filter(function(e4) {
        return t3 !== e4;
      });
    };
  } }, { key: "$emit", value: function(e3, t3) {
    var n3 = this.events[e3];
    n3 && n3.forEach(function(e4) {
      return e4(t3);
    });
  } }]) && r(t2.prototype, n2), o2 && r(t2, o2), Object.defineProperty(t2, "prototype", { writable: false }), e2;
}())();
var f = ["fullscreenControl", "geolocationControl", "routeEditor", "rulerControl", "searchControl", "trafficControl", "typeSelector", "zoomControl", "routeButtonControl", "routePanelControl"];
function h2(e2) {
  return 0 === e2.filter(function(e3) {
    return ![].concat(f, ["default"]).includes(e3);
  }).length;
}
function y() {
  var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  return new Promise(function(t2, n2) {
    if (window.ymaps)
      return t2();
    if (document.getElementById("vue-yandex-maps"))
      d.$on("scriptIsLoaded", t2);
    else {
      var o2 = document.createElement("SCRIPT"), r2 = e2.apiKey, a2 = void 0 === r2 ? "" : r2, i2 = e2.lang, s2 = void 0 === i2 ? "ru_RU" : i2, c2 = e2.version, l2 = void 0 === c2 ? "2.1" : c2, u2 = e2.coordorder, p2 = void 0 === u2 ? "latlong" : u2, m2 = e2.debug, f2 = void 0 !== m2 && m2, h3 = e2.enterprise, y2 = void 0 !== h3 && h3, b2 = f2 ? "debug" : "release", v2 = "lang=".concat(s2).concat(a2 && "&apikey=".concat(a2), "&mode=").concat(b2, "&coordorder=").concat(p2), g2 = "https://".concat(y2 ? "enterprise." : "", "api-maps.yandex.ru/").concat(l2, "/?").concat(v2);
      o2.setAttribute("src", g2), o2.setAttribute("async", ""), o2.setAttribute("defer", ""), o2.setAttribute("id", "vue-yandex-maps"), document.head.appendChild(o2), d.scriptIsNotAttached = false, o2.onload = function() {
        ymaps.ready(function() {
          d.ymapReady = true, d.$emit("scriptIsLoaded"), t2();
        });
      }, o2.onerror = n2;
    }
  });
}
var b;
var v = 1;
var g = d;
var k = ["actionend", "balloonclose", "balloonopen", "click", "contextmenu", "dblclick", "destroy", "hintclose", "hintopen", "optionschange", "sizechange", "typechange"];
var O = { pluginOptions: {}, provide: function() {
  var e2, t2, n2, o2, r2, a2, i2 = this, s2 = [], c2 = [];
  return null != this.balloonComponent && (o2 = this.balloonComponent, r2 = null, a2 = "vue-balloon-".concat(v), v += 1, n2 = function(e3, t3) {
    var n3 = ymaps.templateLayoutFactory.createClass('<div id="'.concat(a2, '"><div>'), { build: function() {
      n3.superclass.build.call(this), (r2 = new b({ parent: e3.$root, data: function() {
        return { props: e3.$props, listeners: e3.$listeners };
      }, propsData: { marker: t3, component: o2 } })).$mount("#".concat(a2));
    }, clear: function() {
      r2.$destroy(), r2 = null, n3.superclass.clear.call(this);
    } });
    return n3;
  }), { useObjectManager: this.useObjectManager, addMarker: this.addMarker, deleteMarker: function(t3) {
    i2.myMap.geoObjects && (s2.push(t3), e2 && clearTimeout(e2), e2 = setTimeout(function() {
      i2.deleteMarkers(s2), s2 = [];
    }, 0));
  }, compareValues: function(e3) {
    var n3 = e3.newVal, o3 = e3.oldVal, r3 = e3.marker;
    m(n3, o3) || (c2.push(r3), t2 && clearTimeout(t2), t2 = setTimeout(function() {
      i2.setMarkers(c2), c2 = [];
    }, 0));
  }, makeComponentBalloonTemplate: n2 };
}, data: function() {
  return { ymapId: "yandexMap".concat(Math.round(1e5 * Math.random())), style: this.ymapClass ? "" : "width: 100%; height: 100%;", isReady: false, debounce: null };
}, props: { coords: { type: Array, required: true }, zoom: { validator: function(e2) {
  return !Number.isNaN(e2);
}, default: 18 }, bounds: Array, clusterOptions: { type: Object, default: function() {
  return {};
} }, clusterCallbacks: { type: Object, default: function() {
  return {};
} }, behaviors: { type: Array, default: function() {
  return ["default"];
} }, controls: { type: Array, default: function() {
  return ["default"];
}, validator: function(e2) {
  return h2(e2);
} }, detailedControls: { type: Object, validator: function(e2) {
  return h2(Object.keys(e2));
} }, scrollZoom: { type: Boolean, default: true }, mapType: { type: String, default: "map", validator: function(e2) {
  return ["map", "satellite", "hybrid"].includes(e2);
} }, placemarks: { type: Array, default: function() {
  return [];
} }, useObjectManager: { type: Boolean, default: false }, objectManagerClusterize: { type: Boolean, default: true }, ymapClass: String, initWithoutMarkers: { type: Boolean, default: true }, debug: { type: Boolean, default: false }, settings: { type: Object, default: function() {
  return {};
} }, options: { type: Object, default: function() {
  return {};
} }, mapEvents: { type: Array, default: function() {
  return [];
} }, showAllMarkers: Boolean, disablePan: Boolean, balloonComponent: { type: [Object, Function], default: function() {
  return null;
} }, useHtmlInLayout: Boolean }, computed: { coordinates: function() {
  return this.coords.map(function(e2) {
    return +e2;
  });
} }, methods: { init: function() {
  var e2, t2, n2 = this;
  if (this.myMap = {}, this.markers = [], window.ymaps && ymaps.GeoObjectCollection && (this.initWithoutMarkers || null !== (e2 = (t2 = this.$slots).default) && void 0 !== e2 && e2.call(t2) || this.placemarks.length)) {
    if (this.$emit("map-initialization-started"), this.myMap = new ymaps.Map(this.ymapId, { center: this.coordinates, zoom: +this.zoom, bounds: this.bounds, behaviors: this.behaviors, controls: this.controls, type: "yandex#".concat(this.mapType) }, this.options), (this.mapEvents.length ? this.mapEvents : k).forEach(function(e3) {
      return n2.myMap.events.add(e3, function(t3) {
        return n2.$emit(e3, t3);
      });
    }), this.myMap.events.add("boundschange", function(e3) {
      var t3 = e3.originalEvent, o2 = t3.newZoom, r2 = t3.newCenter, a2 = t3.newBounds;
      n2.$emit("boundschange", e3), n2.$emit("update:zoom", o2), n2.$emit("update:coords", r2), n2.$emit("update:bounds", a2);
    }), this.detailedControls)
      Object.keys(this.detailedControls).forEach(function(e3) {
        n2.myMap.controls.remove(e3), n2.myMap.controls.add(e3, n2.detailedControls[e3]);
      });
    false === this.scrollZoom && this.myMap.behaviors.disable("scrollZoom"), this.isReady = true, this.$emit("map-was-initialized", this.myMap);
  }
}, addMarker: function(e2) {
  var t2 = this;
  this.markers.push(e2), this.debounce && clearTimeout(this.debounce), this.debounce = setTimeout(function() {
    t2.setMarkers(t2.markers);
  }, 0);
}, setMarkers: function(e2) {
  var t2 = this, n2 = { options: this.clusterOptions, callbacks: this.clusterCallbacks, map: this.myMap, useObjectManager: this.useObjectManager, objectManagerClusterize: this.objectManagerClusterize, useHtmlInLayout: this.useHtmlInLayout };
  if (this.markers !== e2) {
    var o2 = e2.map(function(e3) {
      return t2.useObjectManager ? e3.id : e3.properties.get("markerId");
    });
    this.deleteMarkers(o2), c(e2, n2), this.$emit("markers-was-change", o2);
  } else
    c(e2, n2);
  this.markers = [], this.showAllMarkers && this.myMap.setBounds(this.myMap.geoObjects.getBounds());
}, deleteMarkers: function(e2) {
  var t2 = this, n2 = [];
  this.myMap.geoObjects.each(function(e3) {
    return n2.push(e3);
  }), n2.forEach(function(n3) {
    var o2 = [];
    if (t2.useObjectManager)
      n3.remove(e2);
    else {
      var r2, a2 = function(t3) {
        var n4 = t3.properties.get("markerId");
        e2.includes(n4) && o2.push(t3);
      };
      if (n3.each)
        n3.each(a2), r2 = n3.getLength();
      else if (n3.getGeoObjects) {
        var i2 = n3.getGeoObjects();
        i2.forEach(a2), r2 = i2.length;
      }
      0 === r2 || r2 === o2.length ? t2.myMap.geoObjects.remove(n3) : o2.length && o2.forEach(function(e3) {
        return n3.remove(e3);
      });
    }
  }), this.$emit("markers-was-delete", e2);
} }, watch: { coordinates: function(e2) {
  this.myMap && (this.disablePan ? this.myMap.setCenter && this.myMap.setCenter(e2) : this.myMap.panTo && this.myMap.getZoom() && this.myMap.panTo(e2, { checkZoomRange: true }));
}, zoom: function() {
  this.myMap.setZoom(this.zoom);
}, bounds: function(e2) {
  this.myMap.setBounds && this.myMap.setBounds(e2);
} }, render: function() {
  var t2, n2;
  return h("section", { class: "ymap-container", ref: "mapContainer" }, [h("div", { id: this.ymapId, class: this.ymapClass, style: this.style }), this.isReady && h("div", [null === (t2 = (n2 = this.$slots).default) || void 0 === t2 ? void 0 : t2.call(n2)])]);
}, mounted: function() {
  var e2 = this;
  if (this.$attrs["map-link"] || this.$attrs.mapLink)
    throw new Error("Vue-yandex-maps: Attribute mapLink is not supported. Use settings.");
  if (this.placemarks && this.placemarks.length)
    throw new Error("Vue-yandex-maps: Attribute placemarks is not supported. Use marker component.");
  this.mapObserver = new MutationObserver(function() {
    e2.myMap.container && e2.myMap.container.fitToViewport();
  });
  var t2 = this.$refs.mapContainer;
  if (this.mapObserver.observe(t2, { attributes: true, childList: true, characterData: true, subtree: false }), g.scriptIsNotAttached) {
    var o2 = this.debug;
    y(n(n(n({}, this.$options.pluginOptions), this.settings), {}, { debug: o2 }));
  }
  g.ymapReady ? ymaps.ready(this.init) : g.$on("scriptIsLoaded", this.init);
}, beforeUnmount: function() {
  this.myMap.geoObjects && this.myMap.geoObjects.removeAll();
} };
var C = ["placemark", "polyline", "rectangle", "polygon", "circle"];
var j = ["balloonclose", "balloonopen", "click", "contextmenu", "dblclick", "drag", "dragend", "dragstart", "hintclose", "hintopen", "mouseenter", "mouseleave"];
var M = { inject: ["useObjectManager", "addMarker", "deleteMarker", "compareValues", "makeComponentBalloonTemplate"], props: { coords: Array, hintContent: String, icon: Object, balloon: Object, markerType: { type: String, validator: function(e2) {
  return C.includes(e2.toLowerCase());
}, default: "placemark" }, markerFill: Object, markerStroke: Object, clusterName: [String, Number], circleRadius: { validator: function(e2) {
  return !Number.isNaN(e2);
}, default: 1e3 }, balloonTemplate: String, markerId: { type: [String, Number], required: true }, properties: Object, options: Object, balloonComponentProps: { type: Object, default: function() {
  return {};
} }, markerEvents: { type: Array, default: function() {
  return [];
} } }, data: function() {
  return { unwatchArr: [] };
}, render: function() {
  return this.$slots.balloon && h("div", { style: "display: none;" }, [this.$slots.balloon()]);
}, mounted: function() {
  var e2 = this;
  Object.keys(this.$props).forEach(function(t2) {
    "balloonComponentProps" !== t2 && e2.unwatchArr.push(e2.$watch(t2, function(t3, n2) {
      return e2.compareValues({ newVal: t3, oldVal: n2, marker: e2.defineMarker() });
    }));
  }), this.addMarker(this.defineMarker());
}, methods: { defineMarker: function() {
  var e2 = this, t2 = { markerId: this.markerId, markerType: this.markerType || "placemark", coords: p(this.coords), hintContent: this.hintContent, markerFill: this.markerFill, circleRadius: +this.circleRadius, clusterName: this.clusterName, markerStroke: this.markerStroke, balloon: this.balloon, properties: this.properties, options: this.options, balloonOptions: {} }, n2 = null;
  this.balloonTemplate && (n2 = ymaps.templateLayoutFactory.createClass(this.balloonTemplate)), this.$slots.balloon && (n2 = ymaps.templateLayoutFactory.createClass(this.$slots.balloon()[0].elm.outerHTML)), this.makeComponentBalloonTemplate && (n2 = this.makeComponentBalloonTemplate(this, t2)), null != n2 && (t2.balloonOptions.balloonContentLayout = n2), this.icon && ["default#image", "default#imageWithContent"].includes(this.icon.layout) ? (t2.iconContent = this.icon.content, t2.iconLayout = this.icon.layout, t2.iconImageHref = this.icon.imageHref, t2.iconImageSize = this.icon.imageSize, t2.iconImageOffset = this.icon.imageOffset, t2.iconContentOffset = this.icon.contentOffset, this.icon.contentLayout && "string" == typeof this.icon.contentLayout && (t2.iconContentLayout = ymaps.templateLayoutFactory.createClass(this.icon.contentLayout))) : t2.icon = this.icon;
  var o2 = function(e3, t3) {
    var n3 = l(e3);
    if (!t3)
      return n3;
    switch (n3) {
      case "Placemark":
        return "Point";
      case "Polyline":
        return "LineString";
      default:
        return n3;
    }
  }(t2.markerType, this.useObjectManager), r2 = { hintContent: t2.hintContent, iconContent: t2.icon ? t2.icon.content : t2.iconContent, markerId: t2.markerId }, a2 = t2.balloon ? { balloonContentHeader: t2.balloon.header, balloonContentBody: t2.balloon.body, balloonContentFooter: t2.balloon.footer } : {}, i2 = Object.assign(r2, a2, t2.properties), s2 = t2.iconLayout ? { iconLayout: t2.iconLayout, iconImageHref: t2.iconImageHref, iconImageSize: t2.iconImageSize, iconImageOffset: t2.iconImageOffset, iconContentOffset: t2.iconContentOffset, iconContentLayout: t2.iconContentLayout } : { preset: t2.icon && "islands#".concat(u(t2), "Icon") }, c2 = t2.markerStroke ? { strokeColor: t2.markerStroke.color || "0066ffff", strokeOpacity: parseFloat(t2.markerStroke.opacity) >= 0 ? parseFloat(t2.markerStroke.opacity) : 1, strokeStyle: t2.markerStroke.style, strokeWidth: parseFloat(t2.markerStroke.width) >= 0 ? parseFloat(t2.markerStroke.width) : 1 } : {}, m2 = t2.markerFill ? { fill: t2.markerFill.enabled || true, fillColor: t2.markerFill.color || "0066ff99", fillOpacity: parseFloat(t2.markerFill.opacity) >= 0 ? parseFloat(t2.markerFill.opacity) : 1, fillImageHref: t2.markerFill.imageHref || "" } : {}, d2 = Object.assign(s2, c2, m2, t2.balloonOptions, t2.options);
  "Circle" === o2 && (t2.coords = [t2.coords, t2.circleRadius]);
  var f2 = function(e3, t3) {
    var n3 = t3 ? { type: "Feature", id: e3.properties.markerId, geometry: { type: e3.markerType, coordinates: e3.coords }, properties: e3.properties, options: e3.options } : new ymaps[e3.markerType](e3.coords, e3.properties, e3.options);
    return n3.clusterName = e3.clusterName, n3;
  }({ properties: i2, options: d2, markerType: o2, coords: t2.coords, clusterName: t2.clusterName }, this.useObjectManager, this.$emit);
  this.useObjectManager || (this.markerEvents.length ? this.markerEvents : j).forEach(function(t3) {
    return f2.events.add(t3, function(n3) {
      return e2.$emit(t3, n3);
    });
  });
  return f2;
} }, beforeUnmount: function() {
  this.unwatchArr.forEach(function(e2) {
    return e2();
  }), this.deleteMarker(this.markerId);
} };
O.install = function e(t2) {
  var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  e.installed || (e.installed = true, O.pluginOptions = n2, t2.component("yandex-map", O), t2.component("ymap-marker", M));
}, "undefined" != typeof window && window.Vue && window.Vue.use(O);
var w = y;
var I = O;
var L = M;
var vue_yandex_maps_esm_default = O;
export {
  vue_yandex_maps_esm_default as default,
  w as loadYmap,
  I as yandexMap,
  L as ymapMarker
};
//# sourceMappingURL=vue-yandex-maps.js.map
